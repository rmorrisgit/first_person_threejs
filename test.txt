

//////////////////////////////////////////////////////////////////////////////////////

  // const listener = new THREE.AudioListener();
  // camera.add(listener);
  // this.footstepSound_ = new THREE.Audio(listener);
  // const audioLoader = new THREE.AudioLoader();
  // Load the footstep audio
  // audioLoader.load('./sounds/footstep.ogg', (buffer) => {
  //   this.footstepSound_.setBuffer(buffer);
  //   this.footstepSound_.setLoop(false); // Prevent looping
  //   this.footstepSound_.setVolume(0.5);
  // }, undefined, (error) => {
  //   console.error('An error occurred while loading the audio file:', error);
  // });



///////////////////////////////////////////////////////////////////////////////
  updateHeadBob_(timeElapsedS) {
    if (this.isJumping) {
    // Do not apply head bobbing when jumping
    this.headBobTimer_ = 0; 
    // if (this.footstepSound_.isPlaying) {
    //     this.footstepSound_.stop(); 
    // }
    // return; 
    }
    if (this.headBobActive_) {
      const wavelength = Math.PI;
      const nextStep = 1 + Math.floor(((this.headBobTimer_ + 0.000001) * this.headBobSpeed_) / wavelength);
      const nextStepTime = nextStep * wavelength / this.headBobSpeed_;
      this.headBobTimer_ = Math.min(this.headBobTimer_ + timeElapsedS, nextStepTime);

      if (this.headBobTimer_ == nextStepTime) {
        this.headBobActive_ = false;
      }    
          // if (this.footstepSound_.isPlaying) {
          //   this.footstepSound_.stop();
          // }
      
    }
  }


///////////////////////////////////////////////////////////////////////////////////////


  // Play footstep sound with a delay when moving and grounded
  // if (this.isMoving) {
  //     const currentTime = performance.now();
  //     if (currentTime - (this.lastFootstepTime_ || 0) > 500) { // 500 ms delay
  //         if (!this.footstepSound_.isPlaying) {
  //             this.footstepSound_.play();
  //             this.lastFootstepTime_ = currentTime; // Update the last footstep time
  //         }
  //     }
  // } else {
  //     if (this.footstepSound_.isPlaying) {
  //         this.footstepSound_.stop();
  //     }
  //     this.headBobActive_ = false;
  // }

//////////////////////////////////////////////////////////////

    // const loader = new THREE.CubeTextureLoader();
    // const texture = loader.load([
    //     'resources/skybox/Cold_Sunset__Cam_2_Left+X.png',   // Left (-X)
    //     'resources/skybox/Cold_Sunset__Cam_3_Right-X.png',  // Right (+X)
    //     'resources/skybox/Cold_Sunset__Cam_4_Up+Y.png',     // Top (+Y)
    //     'resources/skybox/Cold_Sunset__Cam_5_Down-Y.png',   // Bottom (-Y)
    //     'resources/skybox/Cold_Sunset__Cam_0_Front+Z.png',  // Front (+Z)
    //     'resources/skybox/Cold_Sunset__Cam_1_Back-Z.png'    // Back (-Z)
    // ]);
    // texture.encoding = THREE.sRGBEncoding;
    // this.scene_.background = texture;


////////////////////////////////////////////////////////////////////////////////////////////////






// Function to get terrain height at specific (x, z) position
const getTerrainHeight = (x, z) => {
  const raycaster = new THREE.Raycaster();
  raycaster.set(new THREE.Vector3(x, 50, z), new THREE.Vector3(0, -1, 0));  
  const intersects = raycaster.intersectObject(terrain);
  return intersects.length > 0 ? intersects[0].point.y : terrain.position.y;  
};

const treeModels = [];

// Load each GLB tree model
const loader3 = new GLTFLoader();
const treePaths = [
  'resources/Tree.glb',
  'resources/TreeFall.glb',
  'resources/TreeLarge.glb',
  'resources/TreeFallLarge.glb'
];
  
// Load each tree model and store promises
const loadTreePromises = treePaths.map((path, index) =>
  new Promise((resolve, reject) => {
    loader3.load(
      path,
      (gltf) => {
        const treeModel = gltf.scene;
        treeModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });
        treeModels[index] = treeModel; // Store the loaded model
        resolve();
      },
      undefined,
      (error) => reject(error)
    );
  })
);


// Wait for all tree models to load, then place trees
Promise.all(loadTreePromises)
  .then(() => {
    placeTrees(terrain);
  
// Place trees on the mirrored terrain
    console.log("All trees placed on the terrain.");
  })
  .catch((error) => console.error("Error loading tree models:", error));
  




















///////////////////////////////////////////////////////////////////////////////







// Function to place trees on terrain
// const placeTrees = () => {
//   const numTrees = 80;

//   // Define exclusion zone after rotation; let's say we want the north edge to be free of trees
//   const exclusionZoneWidth = terrainWidth * 0.3; // Exclude 10% of terrain width on the specified side
//   const exclusionStartX = terrain.position.x + terrainWidth / 2 - exclusionZoneWidth; // Adjusted for rotated terrain

//   for (let i = 0; i < numTrees; i++) {
//     const x = Math.random() * terrainWidth - terrainWidth / 2 + terrain.position.x;
//     const z = Math.random() * terrainHeight - terrainHeight / 2 + terrain.position.z;
  
//     // Skip placing trees within 10% of the specified perpendicular edge along x-axis
//     if (x > exclusionStartX && x < exclusionStartX + exclusionZoneWidth) continue;
  
//     const y = getTerrainHeight(x, z);
//     const treeClone = treeModels[Math.floor(Math.random() * treeModels.length)].clone();
//     treeClone.position.set(x, y, z);
//     treeClone.rotation.y = Math.random() * Math.PI * 2;
// // Set a larger range for more size variation
// treeClone.scale.setScalar(2 + Math.random() * 2.5);
//     this.scene_.add(treeClone);
// }

// };

//////////////////////////////////////////////////////////////

  loadMaterial_(name, tiling) {
    const mapLoader = new THREE.TextureLoader();
    const maxAnisotropy = this.threejs_.capabilities.getMaxAnisotropy();
    const metalMap = mapLoader.load('resources/freepbr/' + name + 'metallic.png');

    metalMap.anisotropy = maxAnisotropy;
    metalMap.wrapS = THREE.RepeatWrapping;
    metalMap.wrapT = THREE.RepeatWrapping;
    metalMap.repeat.set(tiling, tiling);

    const albedo = mapLoader.load('resources/freepbr/' + name + 'albedo.png');
    albedo.anisotropy = maxAnisotropy;
    albedo.wrapS = THREE.RepeatWrapping;
    albedo.wrapT = THREE.RepeatWrapping;
    albedo.repeat.set(tiling, tiling);
    albedo.encoding = THREE.sRGBEncoding;

    const normalMap = mapLoader.load('resources/freepbr/' + name + 'normal.png');
    normalMap.anisotropy = maxAnisotropy;
    normalMap.wrapS = THREE.RepeatWrapping;
    normalMap.wrapT = THREE.RepeatWrapping;
    normalMap.repeat.set(tiling, tiling);

    const roughnessMap = mapLoader.load('resources/freepbr/' + name + 'roughness.png');
    roughnessMap.anisotropy = maxAnisotropy;
    roughnessMap.wrapS = THREE.RepeatWrapping;
    roughnessMap.wrapT = THREE.RepeatWrapping;
    roughnessMap.repeat.set(tiling, tiling);

    const material = new THREE.MeshStandardMaterial({
      metalnessMap: metalMap,
      map: albedo,
      normalMap: normalMap,
      roughnessMap: roughnessMap,
    });

    return material;
  }

//////////////////////////////////////////////////////////////



const terrainWidth = 80;
const terrainHeight = 100;
const segments = 100; // Higher segment count for more detail in height adjustments
const flatEdgeMargin = 10; // Distance from the edges for standard flattening
const extendedEastMargin = 190; // Extended margin for the east edge flattening

const geometry = new THREE.PlaneGeometry(terrainWidth, terrainHeight, segments, segments);
geometry.rotateX(-Math.PI / 2); // Rotate to lie flat on the X-Z plane

const vertices = geometry.attributes.position.array;
for (let i = 0; i < vertices.length; i += 3) {
  const x = vertices[i];
  const z = vertices[i + 2];

  // Calculate the distance to each edge with different margins
  const distanceToWestEdge = Math.max(0, ((-x) - (terrainWidth / 2 - flatEdgeMargin)) / flatEdgeMargin);
  const distanceToNorthEdge = Math.max(0, (z - (terrainHeight / 2 - flatEdgeMargin)) / flatEdgeMargin);
  const distanceToSouthEdge = Math.max(0, ((-z) - (terrainHeight / 2 - flatEdgeMargin)) / flatEdgeMargin);
  
  // Extended flattening for the east edge (positive X-axis)
  const distanceToEastEdge = Math.max(0, (x - (terrainWidth / 2 - extendedEastMargin)) / extendedEastMargin);

  // Apply the maximum distance as the edge factor, prioritizing the extended east edge
  const edgeFactor = Math.max(distanceToWestEdge, distanceToNorthEdge, distanceToSouthEdge, distanceToEastEdge);

  // Increase bumpiness with higher frequency in the center
  const bumpFrequency = 0.3; // Higher frequency for more bumps
  const height = Math.sin(x * bumpFrequency) * Math.cos(z * bumpFrequency) * 8; // Increase amplitude for taller bumps
  vertices[i + 1] = height * (1 - edgeFactor); // Gradually reduce height to zero at the edges
}

geometry.attributes.position.needsUpdate = true;
geometry.computeVertexNormals();

// Create and add the terrain mesh
const terrainMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
const terrain = new THREE.Mesh(geometry, terrainMaterial);
terrain.receiveShadow = true;

terrain.position.y = -1; // Set to ground level
terrain.position.x = -27;
terrain.position.z = -5;

this.scene_.add(terrain);