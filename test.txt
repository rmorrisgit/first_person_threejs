












// Function to get terrain height at specific (x, z) position
const getTerrainHeight = (x, z) => {
  const raycaster = new THREE.Raycaster();
  raycaster.set(new THREE.Vector3(x, 50, z), new THREE.Vector3(0, -1, 0));  
  const intersects = raycaster.intersectObject(terrain);
  return intersects.length > 0 ? intersects[0].point.y : terrain.position.y;  
};

const treeModels = [];

// Load each GLB tree model
const loader3 = new GLTFLoader();
const treePaths = [
  'resources/Tree.glb',
  'resources/TreeFall.glb',
  'resources/TreeLarge.glb',
  'resources/TreeFallLarge.glb'
];
  
// Load each tree model and store promises
const loadTreePromises = treePaths.map((path, index) =>
  new Promise((resolve, reject) => {
    loader3.load(
      path,
      (gltf) => {
        const treeModel = gltf.scene;
        treeModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });
        treeModels[index] = treeModel; // Store the loaded model
        resolve();
      },
      undefined,
      (error) => reject(error)
    );
  })
);


// Wait for all tree models to load, then place trees
Promise.all(loadTreePromises)
  .then(() => {
    placeTrees(terrain);
  
// Place trees on the mirrored terrain
    console.log("All trees placed on the terrain.");
  })
  .catch((error) => console.error("Error loading tree models:", error));
  




















///////////////////////////////////////////////////////////////////////////////







// Function to place trees on terrain
// const placeTrees = () => {
//   const numTrees = 80;

//   // Define exclusion zone after rotation; let's say we want the north edge to be free of trees
//   const exclusionZoneWidth = terrainWidth * 0.3; // Exclude 10% of terrain width on the specified side
//   const exclusionStartX = terrain.position.x + terrainWidth / 2 - exclusionZoneWidth; // Adjusted for rotated terrain

//   for (let i = 0; i < numTrees; i++) {
//     const x = Math.random() * terrainWidth - terrainWidth / 2 + terrain.position.x;
//     const z = Math.random() * terrainHeight - terrainHeight / 2 + terrain.position.z;
  
//     // Skip placing trees within 10% of the specified perpendicular edge along x-axis
//     if (x > exclusionStartX && x < exclusionStartX + exclusionZoneWidth) continue;
  
//     const y = getTerrainHeight(x, z);
//     const treeClone = treeModels[Math.floor(Math.random() * treeModels.length)].clone();
//     treeClone.position.set(x, y, z);
//     treeClone.rotation.y = Math.random() * Math.PI * 2;
// // Set a larger range for more size variation
// treeClone.scale.setScalar(2 + Math.random() * 2.5);
//     this.scene_.add(treeClone);
// }

// };

//////////////////////////////////////////////////////////////

  loadMaterial_(name, tiling) {
    const mapLoader = new THREE.TextureLoader();
    const maxAnisotropy = this.threejs_.capabilities.getMaxAnisotropy();
    const metalMap = mapLoader.load('resources/freepbr/' + name + 'metallic.png');

    metalMap.anisotropy = maxAnisotropy;
    metalMap.wrapS = THREE.RepeatWrapping;
    metalMap.wrapT = THREE.RepeatWrapping;
    metalMap.repeat.set(tiling, tiling);

    const albedo = mapLoader.load('resources/freepbr/' + name + 'albedo.png');
    albedo.anisotropy = maxAnisotropy;
    albedo.wrapS = THREE.RepeatWrapping;
    albedo.wrapT = THREE.RepeatWrapping;
    albedo.repeat.set(tiling, tiling);
    albedo.encoding = THREE.sRGBEncoding;

    const normalMap = mapLoader.load('resources/freepbr/' + name + 'normal.png');
    normalMap.anisotropy = maxAnisotropy;
    normalMap.wrapS = THREE.RepeatWrapping;
    normalMap.wrapT = THREE.RepeatWrapping;
    normalMap.repeat.set(tiling, tiling);

    const roughnessMap = mapLoader.load('resources/freepbr/' + name + 'roughness.png');
    roughnessMap.anisotropy = maxAnisotropy;
    roughnessMap.wrapS = THREE.RepeatWrapping;
    roughnessMap.wrapT = THREE.RepeatWrapping;
    roughnessMap.repeat.set(tiling, tiling);

    const material = new THREE.MeshStandardMaterial({
      metalnessMap: metalMap,
      map: albedo,
      normalMap: normalMap,
      roughnessMap: roughnessMap,
    });

    return material;
  }

//////////////////////////////////////////////////////////////
